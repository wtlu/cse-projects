; CSE 341 BASIC Expression Parser (obfuscated)
(define (parse-test b) (let ((a (parse-expression b))) (if (< (length a) 3) (error "illegal test") (let* ((c (cadr a)) (d (if (eq? c '<>) (lambda (g h) (not (= g h))) (eval c))) (i (parse-expression (cddr a)))) (if (member c '(< > <= >= = <>)) (cons (d (car a) (car i)) (cdr i)) (error "illegal test"))))))
(define (parse-factor a) (if (not (pair? a)) (error "illegal factor") (let* ((b (car a)) (c (assoc b d))) (cond ((number? b) a) ((eq? b 'lparen) (let ((e (parse-expression (cdr a)))) (if (and (> (length e) 1) (eq? (cadr e) 'rparen)) (cons (car e) (cddr e)) (error "illegal factor")))) ((and c (> (length a) 1) (eq? (cadr a) 'lparen)) (let ((e (parse-expression (cddr a)))) (if (and (> (length e) 1) (eq? (cadr e) 'rparen)) (cons ((eval (cdr c)) (car e)) (cddr e)) (error "illegal factor")))) ((eq? b '-) (let ((e (parse-factor (cdr a)))) (cons (- (car e)) (cdr e)))) ((eq? b '+) (parse-factor (cdr a))) (else (error "illegal factor"))))))
(define (parse-term b) (let ((a (parse-element b))) (cond ((and (> (length a) 1) (eq? (cadr a) '*)) (let ((c (parse-element (cddr a)))) (parse-term (cons (* (car a) (car c)) (cdr c))))) ((and (> (length a) 1) (eq? (cadr a) '/)) (let ((c (parse-element (cddr a)))) (parse-term (cons (exact->inexact (/ (car a) (car c))) (cdr c))))) (else a))))
(define (parse-element e) (let ((a (lambda (b c) (if (< c 0) (exact->inexact (expt b c)) (expt b c)))) (d (parse-factor e))) (cond ((and (> (length d) 1) (eq? (cadr d) '^)) (let ((g (parse-factor (cddr d)))) (parse-element (cons (a (car d) (car g)) (cdr g))))) (else d))))
(define (parse-expression b) (let ((a (parse-term b))) (cond ((and (> (length a) 1) (eq? (cadr a) '+)) (let ((c (parse-term (cddr a)))) (parse-expression (cons (+ (car a) (car c)) (cdr c))))) ((and (> (length a) 1) (eq? (cadr a) '-)) (let ((c (parse-term (cddr a)))) (parse-expression (cons (- (car a) (car c)) (cdr c))))) (else a))))
(define d '((SIN . sin) (COS . cos) (TAN . tan) (ATN . atan) (EXP . exp) (ABS . abs)  (LOG . log) (SQR . sqrt) (RND . r) (INT . t)))
(define (r n) (random)) (define (t n) (inexact->exact (truncate n)))
